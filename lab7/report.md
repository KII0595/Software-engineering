# Отчет по лабораторной работе №7  
## Конкурентное программирование в языке Go

**Дата:** 2025-12-28  
**Семестр:** 2 курс, 1 полугодие (3 семестр)  
**Группа:** ПИН-б-о-24-1  
**Дисциплина:** Технологии программирования  
**Студент:** Кочкарев Ислам Ильясович  

### Цель работы
Практическое изучение средств конкурентного программирования в Go: горутины, каналы, группы синхронизации, контексты. Реализация классических паттернов параллельной обработки данных и создание простого веб-сервера с поддержкой graceful shutdown.

### Среда выполнения
Работа выполнена в операционной системе **Windows 10** с использованием PowerShell и официального компилятора Go версии 1.23.

### Структура проекта

```
lab7-go-concurrency/
├── main.go                  // запуск всех демонстраций
├── core/
│   ├── sync.go              // базовая синхронизация и атомарные операции
│   ├── channels.go          // каналы с поддержкой контекста
│   └── patterns.go          // Worker Pool, Pipeline, Fan-Out/Fan-In
└── server/
└── api.go               // HTTP-сервер с метриками и middleware
```

### Основные реализованные компоненты
- Безопасная работа с общими данными (мьютексы, атомарные операции)
- Генерация и обработка данных через каналы с отменой по контексту
- Параллельное преобразование коллекций
- Реализация паттернов Worker Pool и Pipeline
- Fan-Out/Fan-In для распределённой обработки
- HTTP-сервер с логированием запросов, восстановлением после паники и graceful shutdown

### Примеры работы

**Атомарный счётчик и параллельное выполнение**

```go
counter := atomic.Uint64{}
var wg sync.WaitGroup
for i := 0; i < 500; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        for j := 0; j < 20; j++ {
            counter.Add(1)
        }
    }()
}
wg.Wait()
fmt.Println("Финальное значение:", counter.Load())
```

### Pipeline из нескольких стадий

```go
result := Pipeline([]int{1, 2, 3, 4, 5},
    func(x int) int { return x * 2 },
    func(x int) int { return x + 3 },
    func(x int) int { return x * x },
)
fmt.Println(result) // [16 25 36 49 64]
```

## Результаты выполнения

Все примеры успешно выполняются без состояний гонки (проверено go run -race).
Веб-сервер корректно обрабатывает параллельные запросы, выводит статистику и завершает работу по сигналу Ctrl+C.

## Выводы

- Горутины в Go — лёгкий и эффективный механизм для запуска тысяч параллельных задач.
 
- Каналы предоставляют типобезопасный способ обмена данными без явных блокировок.

- Паттерны Worker Pool и Pipeline позволяют строить эффективные конвейеры обработки данных.

- Использование context.Context обеспечивает контролируемую отмену длительных операций.

- Встроенная поддержка конкурентности делает Go отличным инструментом для создания высоконагруженных серверных приложений.
