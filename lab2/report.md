# Отчет по лабораторной работе №2  
## Парадигмы программирования в языке R

**Дата:** 2025-10-10  
**Семестр:** 2 курс, 1 полугодие (3 семестр)  
**Группа:** ПИН-б-о-24-1  
**Дисциплина:** Технологии программирования  
**Студент:** Куйбышев Александр Максимович  

---

## Цель работы
Освоить основные парадигмы программирования, поддерживаемые языком R. Изучить их особенности и реализовать примеры кода, демонстрирующие каждый подход.

---

## Краткий обзор парадигм
R поддерживает несколько стилей программирования:
- **Императивный** — последовательное выполнение инструкций с изменением состояния
- **Структурный** — использование управляющих конструкций без переходов goto
- **Объектно-ориентированный** — работа с объектами и классами (R6)
- **Векторный** — поэлементные операции над векторами без циклов
- **Функциональный** — функции как объекты первого класса, функции высшего порядка
- **Грамотное (литературное)** — создание воспроизводимых документов с помощью R Markdown
- **Параллельный** — распределение вычислений по ядрам процессора

---

## Практические примеры

### 1. Императивный стиль
Расчёт суммы элементов вектора с накоплением в переменной.

```r
numbers <- c(10, 15, 20, 25, 30)
total <- 0
for (i in seq_along(numbers)) {
  total <- total + numbers[i]
}
cat("Сумма:", total, "\n")
```

Вывод:
Сумма: 100

---

### 2. Структурный стиль
Функция для определения типа треугольника по длинам сторон.

```r
triangle_type <- function(a, b, c) {
  if (a <= 0 || b <= 0 || c <= 0) {
    return("Некорректные стороны")
  }
  
  sides <- sort(c(a, b, c))
  if (sides[1] + sides[2] <= sides[3]) {
    return("Не существует")
  } else if (a == b && b == c) {
    return("Равносторонний")
  } else if (a == b || b == c || a == c) {
    return("Равнобедренный")
  } else {
    return("Разносторонний")
  }
}

cat(triangle_type(5, 5, 5), "\n")
cat(triangle_type(3, 4, 5), "\n")
```

Использованы только последовательность, ветвление и проверка условий — базовые структуры структурного программирования.

---

### 3. Объектно-ориентированный стиль (R6)
Реализация простых геометрических фигур.

```r
library(R6)

Shape <- R6Class("Shape",
  public = list(
    get_area = function() stop("Метод не реализован")
  )
)

Circle <- R6Class("Circle",
  inherit = Shape,
  public = list(
    radius = NULL,
    initialize = function(r) self$radius <- r,
    get_area = function() pi * self$radius^2
  )
)

Triangle <- R6Class("Triangle",
  inherit = Shape,
  public = list(
    base = NULL, height = NULL,
    initialize = function(b, h) {
      self$base <- b
      self$height <- h
    },
    get_area = function() 0.5 * self$base * self$height
  )
)

c <- Circle$new(7)
t <- Triangle$new(10, 4)
cat("Площадь круга:", c$get_area(), "\n")
cat("Площадь треугольника:", t$get_area(), "\n")
```

Наследование и полиморфизм через переопределение метода get_area.

---

### 4. Векторный стиль
Обработка массива данных о росте студентов.

```r
heights <- c(165, 172, 168, 180, 155, 190, 170, 175, 162, 185)

normalized <- (heights - mean(heights)) / sd(heights)
above_avg <- heights[heights > mean(heights)]
cat("Нормализованные значения:", round(normalized, 2), "\n")
cat("Выше среднего:", above_avg, "\n")
```

Все операции применяются сразу ко всему вектору — типичная векторизация в R.

---

### 5. Функциональный стиль
Применение функций высшего порядка из tidyverse.

```r
library(dplyr)
library(purrr)

datasets <- list(
  set1 = rnorm(100, mean = 0),
  set2 = rnorm(100, mean = 5),
  set3 = rnorm(100, mean = -3)
)

summary_stats <- map_dfr(datasets, ~ tibble(
  mean = mean(.x),
  sd = sd(.x),
  min = min(.x),
  max = max(.x)
), .id = "dataset")

print(summary_stats)
```

Функции map_dfr и анонимные функции (~) демонстрируют функциональный подход.

---

### 6. Грамотное программирование
Пример R Markdown блока (в отчете):

```md
temp_k <- c(273, 293, 310)
temp_c <- temp_k - 273.15
data.frame(Kelvin = temp_k, Celsius = temp_c)
```

R Markdown позволяет объединять код, результаты и пояснения в одном документе, обеспечивая воспроизводимость.

---

### 7. Параллельное программирование
Параллельное вычисление интегралов методом Монте-Карло.

```r
library(parallel)

monte_carlo_pi <- function(n) {
  points <- matrix(runif(2 * n), ncol = 2)
  inside <- rowSums(points^2) < 1
  4 * sum(inside) / n
}

cl <- makeCluster(detectCores() - 1)
clusterExport(cl, "monte_carlo_pi")

results <- parSapply(cl, rep(1000000, 20), monte_carlo_pi)
stopCluster(cl)

cat("Оценка π:", mean(results), "\n")
```

Распараллеливание ускоряет вычисления на многоядерном процессоре.

---

## Выводы
Язык R гибко поддерживает различные парадигмы программирования.
Императивный и структурный стили удобны для простых скриптов.
Векторная обработка — ключевое преимущество R при работе с данными.
Функциональный подход (особенно с tidyverse) делает код лаконичным и выразительным.
ООП через R6 полезно при создании сложных систем.
R Markdown обеспечивает воспроизводимость исследований.
Параллельные вычисления позволяют эффективно использовать современное оборудование.
Изучение разных парадигм расширяет инструментарий разработчика и помогает выбирать наиболее подходящий стиль для конкретной задачи.

---

## Ответы на контрольные вопросы

**Императивное:** изменение состояния через присваивания, последовательное выполнение.  
**Структурное:** три базовые конструкции (последовательность, выбор, повторение).  
**ООП:** инкапсуляция, наследование, полиморфизм.  
**Векторное:** автоматическое применение операций ко всем элементам.  
**Функциональное:** функции как значения, иммутабельность, map/reduce.  
**Грамотное:** интеграция кода и документации в R Markdown.  
**Параллельное:** распределение задач между ядрами (parallel, future).
