# Отчет по лабораторной работе №2
# Основные парадигмы программирования в R

**Дата:** 2025-12-25  
**Семестр:** 2 курс, 1 полугодие (3 семестр)  
**Группа:** ПИН-б-о-24-1  
**Дисциплина:** Технологии программирования  
**Студент:** Кочкарев Ислам Ильясович  

---

## Цель работы
Изучить основные парадигмы программирования, поддерживаемые языком R, разобраться в их ключевых принципах и выполнить практические примеры для лучшего понимания и закрепления материала.

---

## Теоретическая часть

Каждая парадигма программирования предлагает свой способ структурирования кода и решения задач.
В лабораторной работе были рассмотрены следующие подходы:

| Парадигма | Ключевая идея |
|------------|----------------|
| Императивная | Программа — это последовательность инструкций, изменяющих состояние переменных |
| Структурная | Организация кода с помощью последовательности, ветвлений и циклов (без goto) |
| ООП | Моделирование программы как взаимодействия объектов с данными и методами |
| Векторная | Одновременная (поэлементная) обработка целых векторов и массивов данных |
| Функциональная | Использование функций как объектов первого класса и конвейеров обработки |
| Грамотное программирование | Создание воспроизводимых документов с кодом, результатами и пояснениями |
| Параллельная | Распределение вычислений по нескольким ядрам для ускорения выполнения |

---

## Практическая часть

### 1. Императивное (процедурное) программирование

**Задача:** вычислить площади квадрата, прямоугольника и круга, затем найти их суммарную площадь.

```r
# Функции для расчета площадей отдельных фигур
area_square <- function(side) side ^ 2
area_rectangle <- function(length, width) length * width
area_circle <- function(radius) pi * radius ^ 2

# Параметры фигур
side <- 5
length <- 5
width <- 8
radius <- 3

# Последовательное вычисление и суммирование
total <- area_square(side) + area_rectangle(length, width) + area_circle(radius)

cat("Суммарная площадь всех фигур:", round(total, 2), "\n")
```
**Результат:**
```
[1] "Общая площадь: 142.27"
```
Императивный стиль подразумевает явное управление потоком выполнения: мы последовательно определяем функции, задаём значения переменным, вызываем функции и сохраняем результат.

---

### 2. Структурное программирование

**Задача:** [Вариант 16] рассчитать площадь заданных фигур (квадрат, прямоугольник, параллелограмм).

```r
calculate_area <- function(type) {
  type <- tolower(type)
  
  if (type == "квадрат") {
    s <- as.numeric(readline(prompt = "Введите длину стороны квадрата: "))
    return(s ^ 2)
  } else if (type == "прямоугольник") {
    a <- as.numeric(readline(prompt = "Введите первую сторону: "))
    b <- as.numeric(readline(prompt = "Введите вторую сторону: "))
    return(a * b)
  } else if (type == "параллелограмм") {
    base <- as.numeric(readline(prompt = "Введите длину основания: "))
    height <- as.numeric(readline(prompt = "Введите высоту: "))
    return(base * height)
  } else {
    message("Неизвестный тип фигуры")
    return(NA)
  }
}

# Пример вызова (можно раскомментировать для интерактивного ввода)
# calculate_area("прямоугольник")
```
Структурное программирование опирается на три базовые конструкции: последовательность, выбор (if-else) и повторение. В примере использована цепочка ветвлений для обработки разных случаев без переходов goto.

---

### 3. Объектно-ориентированное программирование
                                                                                              
```r
library(R6)

# Базовый класс
Shape <- R6Class("Shape",
  public = list(
    compute_area = function() stop("Метод compute_area должен быть переопределён")
  )
)

# Класс квадрата
Square <- R6Class("Square",
  inherit = Shape,
  public = list(
    side = NULL,
    initialize = function(side) self$side <- side,
    compute_area = function() self$side ^ 2
  )
)

# Класс прямоугольника
Rectangle <- R6Class("Rectangle",
  inherit = Shape,
  public = list(
    length = NULL,
    width = NULL,
    initialize = function(length, width) {
      self$length <- length
      self$width <- width
    },
    compute_area = function() self$length * self$width
  )
)

# Класс параллелограмма
Parallelogram <- R6Class("Parallelogram",
  inherit = Shape,
  public = list(
    base = NULL,
    height = NULL,
    initialize = function(base, height) {
      self$base <- base
      self$height <- height
    },
    compute_area = function() self$base * self$height
  )
)

# Создание объектов и вычисление площадей
sq <- Square$new(4)
rect <- Rectangle$new(5, 8)
paral <- Parallelogram$new(6, 3)

areas <- sapply(list(sq, rect, paral), function(obj) obj$compute_area())
sum(areas)
```
В R система R6 позволяет реализовать классическое ООП с инкапсуляцией, наследованием и полиморфизмом. Все фигуры наследуют общий метод compute_area, который переопределяется в дочерних классах.

---

### 4. Векторное программирование

```r
ages <- c(21, 18, 21, 19, 25, 20, 17, 17, 18, 22,
          17, 18, 18, 19, 19, 27, 21, 20, 24, 17,
          15, 24, 24, 29, 19, 14, 21, 17, 19, 18,
          18, 20, 21, 21, 19, 17, 21, 13, 17, 13,
          23, 15, 23, 24, 16, 17, 25, 24, 22)

avg <- mean(ages)
std <- sd(ages)

# Фильтрация значений в пределах одного стандартного отклонения от среднего
filtered_ages <- ages[abs(ages - avg) < std]
filtered_ages
```
Векторные операции в R выполняются сразу над всеми элементами без явных циклов — это основа эффективности языка при работе с данными.

---

### 5. Функциональное программирование

```r
library(purrr)

data_lists <- list(
  group1 = 1:5,
  group2 = 6:10,
  group3 = 11:15
)

# Применяем функцию mean к каждому элементу списка
map_dbl(data_lists, mean)
```
Функциональный стиль активно использует функции высшего порядка. Функция map_dbl принимает другую функцию (в данном случае анонимную mean) и применяет её ко всем элементам структуры данных.

---

### 6. Грамотное программирование

```md
title: "Пример воспроизводимого отчета"
output: html_document
```
### Преобразование температуры
```{r}
kelvin <- 282.15
celsius <- kelvin - 273.15
celsius
```
R Markdown объединяет повествовательный текст, код R и его результаты в один документ, обеспечивая полную воспроизводимость исследований.

---

### 7. Параллельное программирование

```r
library(parallel)

# Функция, вычисляющая среднее для заданного количества случайных чисел
calc_mean <- function(n) mean(rnorm(n))

# Создаём кластер, используя все ядра кроме одного
cluster <- makeCluster(detectCores() - 1)

# Параллельно вычисляем средние для 50 наборов по 10000 чисел
results <- parSapply(cluster, rep(10000, 50), calc_mean)

stopCluster(cluster)

# Общее среднее всех вычислений
mean(results)
```
Пакет parallel реализует модель master-worker: главный процесс распределяет задачи по рабочим ядрам, собирает результаты и завершает работу кластера.

---

## Выводы
В ходе лабораторной работы были практически изучены ключевые парадигмы программирования в R.

Императивный подход удобен для простых последовательных вычислений. Структурное программирование делает код читаемым и управляемым. ООП (через R6) помогает моделировать реальные сущности. Векторные операции — основа производительности R при анализе данных. Функциональные инструменты (purrr) упрощают трансформацию данных. R Markdown обеспечивает воспроизводимость и грамотную презентацию результатов. Параллельные вычисления существенно ускоряют ресурсоёмкие задачи.

Знание различных парадигм позволяет выбирать наиболее подходящий стиль для конкретной задачи и писать более эффективный и поддерживаемый код на R.

---

## Ответы на контрольные вопросы

**Императивное:** основные элементы — переменные, присваивание, последовательное выполнение команд.  
**Структурное:** основа — теорема Бёма–Якопини о достаточности трёх конструкций управления.  
**ООП:** три главных принципа — инкапсуляция, наследование, полиморфизм.  
**Векторное:** ключевая особенность — векторизация операций (поэлементное применение).  
**Функциональное:** типичные функции высшего порядка — map, reduce, filter.  
**Грамотное:** основной инструмент — R Markdown для создания воспроизводимых отчётов.  
**Параллельное:** распространённая модель — master-worker (главный процесс распределяет задачи).
